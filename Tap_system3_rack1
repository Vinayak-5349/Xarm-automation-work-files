import time
import json
import logging
from xarm.wrapper import XArmAPI

# === Setup Logger ===
logging.basicConfig(
    filename='robot_action.log',
    level=logging.INFO,
    format='%(asctime)s [RECORD] %(message)s',
)

# === Connect to Robot Arm ===
xarm_ip = "192.168.1.189"
arm = XArmAPI(xarm_ip)
arm.connect()
arm.clean_error()
arm.clean_warn()
arm.motion_enable(enable=True)
arm.set_mode(0)
arm.set_state(0)

RECORD_FILE = "tap_system3_rack1.json"
recorded_sequence = {}
import traceback
import inspect

# Error code mapping for xArm (you can expand this list as needed)
ERROR_CODES = {
    -8: "Out of joint range",
    2: "I/O error (e.g., tgpio not available)",
    14: "IK calculation failed",
    0: "Success"
}

import traceback
import inspect

# Error code mapping for xArm (extend as needed)
ERROR_CODES = {
    -8: "Out of joint range",
    2: "I/O error",
    14: "IK calculation failed",
    0: "Success"
}
# === Record step into memory ===
def record_step(step_type, data, delay):
    step = {"type": step_type, "delay": delay}
    step.update(data)
    recorded_sequence["current"].append(step)
    logging.info(f"Recorded step: {step}")

# === Wrapper for recording timed actions ===
def timed_call(step_type, data, func, *args, **kwargs):
    start = time.time()
    func(*args, **kwargs)
    delay = time.time() - start
    record_step(step_type, data, delay)

# === Wrapper for sleep ===
def timed_sleep(duration):
    time.sleep(duration)
    record_step("sleep", {"duration": duration}, duration)

# === Move using Cartesian and record ===
def log_error(code, msg=""):
    if code == 0:
        return
    frame = inspect.currentframe().f_back
    filename = frame.f_code.co_filename
    line_no = frame.f_lineno
    desc = ERROR_CODES.get(code, "Unknown error")
    print(f"[ERROR] Code {code} ({desc}) at {filename}:{line_no} {msg}")
    traceback.print_stack(limit=2)


def move_to_cartesian(cartesian_position, speed=20, comment=None):
    """
    Move robot to a Cartesian position with IK + shortest path + joint limit check,
    while recording the move into the JSON log.
    """
    if comment:
        print(f"--- {comment} ---")

    # Get IK solution
    status_code, joint_angles = arm.get_inverse_kinematics(
        cartesian_position, input_is_radian=False, return_is_radian=False
    )
    if status_code != 0 or not joint_angles:
        log_error(status_code, "while calculating IK")
        logging.error(f"Inverse kinematics failed for position: {cartesian_position}")
        return False

    # Convert to float and only take first 6 axes
    joint_angles = [float(angle) for angle in joint_angles[:6]]

    # Get current joint angles (for shortest path correction)
    _, current_angles = arm.get_servo_angle(is_radian=False)
    if current_angles:
        for i in range(6):
            diff = joint_angles[i] - current_angles[i]
            if diff > 180:
                joint_angles[i] -= 360
            elif diff < -180:
                joint_angles[i] += 360

    # --- SAFETY CHECK for joint limits (in degrees) ---
    joint_limits_deg = [
        (-360, 360),   # J1
        (-120, 120),   # J2
        (-135, 135),   # J3
        (-360, 360),   # J4
        (-120, 120),   # J5
        (-360, 360),   # J6
    ]

    for i, angle in enumerate(joint_angles):
        low, high = joint_limits_deg[i]
        if angle < low or angle > high:
            print(f"[WARNING] Joint {i+1} out of range ({angle:.2f}Â°). Skipping move.")
            return False

    # Send move command WITH RECORDING
    def _do_move():
        return arm.set_servo_angle(angle=joint_angles, speed=speed, is_radian=False, wait=True)

    # timed_call will measure delay + record step automatically
    timed_call("move", {"joints": joint_angles, "speed": speed}, _do_move)

    print("[OK] Move successful")
    return True

def move_along_tool_z(dz, speed=10):
    timed_call("tool_move", {"dx": 0, "dy": 0, "dz": dz, "speed": speed},
               arm.set_tool_position, 0, 0, dz, 0, 0, 0, speed=speed, wait=True)

# === Wrapper for Gripper Open/Close ===
def open_gripper():
    timed_call("gripper_open", {}, lambda: arm.open_lite6_gripper())

def close_gripper():
    timed_call("gripper_close", {}, lambda: arm.close_lite6_gripper())

# === INSERT SEQUENCE RECORDING ===
def tap_rack1():
    logging.info("Started recording: TAP action, Rack 1")
    recorded_sequence["current"] = []
    move_to_cartesian([-2,222.8,301.8,-123.8,0.7,-0.9],speed=95)

    # move_to_cartesian([59.7,230.5,203.6,-146,-1.4,-1.6],speed=60)
    
    # move_to_cartesian([66.9,307.8,117.3,-149.3,0.5,-1.6],speed=60)
    # move_to_cartesian([59.5,308.7,111.3,-127.2,0.4,-6],speed=50)
    move_to_cartesian([61.2,242,207.5,-137.2,0.1,-2],speed=95)
    open_gripper()
    timed_sleep(0.5)
    move_to_cartesian([63.8,318.7,124.6,-137.2,0.1,-2],speed=95)
    close_gripper()
    timed_sleep(0.5)
    move_to_cartesian([61.2,242,207.5,-137.2,0.1,-2],speed=95)

    move_to_cartesian([-2,222.8,301.8,-123.8,0.7,-0.9],speed=95)
    move_to_cartesian([-156.8,224.9,300.4,-91.5,0.6,88.6],speed=95)
    
    move_to_cartesian([-206.7,212.5,198.1,-123.2,0.2,89.9],speed=75)
    timed_sleep(5)
    move_to_cartesian([-156.8,224.9,300.4,-91.5,0.6,88.6],speed=95)
    



    move_to_cartesian([-2,222.8,301.8,-123.8,0.7,-0.9],speed=95)
    move_to_cartesian([61.2,242,207.5,-137.2,0.1,-2],speed=95)
    move_to_cartesian([63.8,318.7,124.6,-137.2,0.1,-2],speed=95)
    open_gripper()
    timed_sleep(0.5)
    move_to_cartesian([61.2,242,207.5,-137.2,0.1,-2],speed=95)
    close_gripper()
    move_to_cartesian([-2,222.8,301.8,-123.8,0.7,-0.9],speed=95)
    






    

    logging.info("Completed recording: TAP action, Rack 1")
    return recorded_sequence["current"]

# === MAIN EXECUTION ===
def main():
    recorded_sequence["current"] = []  
    step_data = {}
    step_data["tap_system3_rack1"] = tap_rack1()

    with open(RECORD_FILE, "w") as f:
        json.dump(step_data, f, indent=4)

    logging.info(f"Saved all recorded steps to {RECORD_FILE}")

if __name__ == "__main__":
    main()
